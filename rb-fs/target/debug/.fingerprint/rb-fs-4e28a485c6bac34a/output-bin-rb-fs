{"message":"unused import: `ReplyOpen`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/mkfs.rs","byte_start":80,"byte_end":89,"line_start":1,"line_end":1,"column_start":81,"column_end":90,"is_primary":true,"text":[{"text":"use fuse::{Filesystem, Request, ReplyCreate, ReplyEmpty, ReplyAttr, ReplyEntry, ReplyOpen, ReplyStatfs,ReplyData, ReplyDirectory, ReplyWrite, FileType, FileAttr};","highlight_start":81,"highlight_end":90}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/mkfs.rs","byte_start":78,"byte_end":89,"line_start":1,"line_end":1,"column_start":79,"column_end":90,"is_primary":true,"text":[{"text":"use fuse::{Filesystem, Request, ReplyCreate, ReplyEmpty, ReplyAttr, ReplyEntry, ReplyOpen, ReplyStatfs,ReplyData, ReplyDirectory, ReplyWrite, FileType, FileAttr};","highlight_start":79,"highlight_end":90}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `ReplyOpen`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/mkfs.rs:1:81\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse fuse::{Filesystem, Request, ReplyCreate, ReplyEmpty, ReplyAttr, ReplyEntry, ReplyOpen, ReplyStatfs,ReplyData, ReplyDirectory, ReplyWr\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused imports: `EISDIR`, `ENOSPC`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/mkfs.rs","byte_start":195,"byte_end":201,"line_start":2,"line_end":2,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"use libc::{ENOSYS, ENOENT, EIO, EISDIR, ENOSPC};","highlight_start":33,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/mkfs.rs","byte_start":203,"byte_end":209,"line_start":2,"line_end":2,"column_start":41,"column_end":47,"is_primary":true,"text":[{"text":"use libc::{ENOSYS, ENOENT, EIO, EISDIR, ENOSPC};","highlight_start":41,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/mkfs.rs","byte_start":193,"byte_end":209,"line_start":2,"line_end":2,"column_start":31,"column_end":47,"is_primary":true,"text":[{"text":"use libc::{ENOSYS, ENOENT, EIO, EISDIR, ENOSPC};","highlight_start":31,"highlight_end":47}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `EISDIR`, `ENOSPC`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/mkfs.rs:2:33\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse libc::{ENOSYS, ENOENT, EIO, EISDIR, ENOSPC};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\n\n"}
{"message":"unused import: `crate::mkfs`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/mkfs.rs","byte_start":251,"byte_end":262,"line_start":5,"line_end":5,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"use crate::mkfs;","highlight_start":5,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/mkfs.rs","byte_start":247,"byte_end":263,"line_start":5,"line_end":5,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"use crate::mkfs;","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `crate::mkfs`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/mkfs.rs:5:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse crate::mkfs;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"type `Mem_block` should have an upper camel case name","code":{"code":"non_camel_case_types","explanation":null},"level":"warning","spans":[{"file_name":"src/mkfs.rs","byte_start":1237,"byte_end":1246,"line_start":40,"line_end":40,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Mem_block {","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(non_camel_case_types)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"convert the identifier to upper camel case","code":null,"level":"help","spans":[{"file_name":"src/mkfs.rs","byte_start":1237,"byte_end":1246,"line_start":40,"line_end":40,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Mem_block {","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":"MemBlock","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: type `Mem_block` should have an upper camel case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/mkfs.rs:40:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct Mem_block {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to upper camel case: `MemBlock`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(non_camel_case_types)]` on by default\u001b[0m\n\n"}
{"message":"type `Rb_fs` should have an upper camel case name","code":{"code":"non_camel_case_types","explanation":null},"level":"warning","spans":[{"file_name":"src/mkfs.rs","byte_start":6950,"byte_end":6955,"line_start":219,"line_end":219,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"pub struct Rb_fs {","highlight_start":12,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to upper camel case","code":null,"level":"help","spans":[{"file_name":"src/mkfs.rs","byte_start":6950,"byte_end":6955,"line_start":219,"line_end":219,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"pub struct Rb_fs {","highlight_start":12,"highlight_end":17}],"label":null,"suggested_replacement":"RbFs","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: type `Rb_fs` should have an upper camel case name\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/mkfs.rs:219:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct Rb_fs {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to upper camel case: `RbFs`\u001b[0m\n\n"}
{"message":"unused import: `std::ffi::OsStr`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":43,"byte_end":58,"line_start":4,"line_end":4,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use std::ffi::OsStr;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":39,"byte_end":59,"line_start":4,"line_end":4,"column_start":1,"column_end":21,"is_primary":true,"text":[{"text":"use std::ffi::OsStr;","highlight_start":1,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::ffi::OsStr`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:4:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse std::ffi::OsStr;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"the trait bound `Luma<u8>: Element` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":534,"byte_end":540,"line_start":24,"line_end":24,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let image = code.render::<Luma<u8>>().build();","highlight_start":22,"highlight_end":28}],"label":"the trait `Element` is not implemented for `Luma<u8>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required because of the requirements on the impl of `qrcode::render::Pixel` for `Luma<u8>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QrCode::render`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":"required by a bound in this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/qrcode-0.11.2/src/lib.rs","byte_start":8173,"byte_end":8178,"line_start":226,"line_end":226,"column_start":22,"column_end":27,"is_primary":true,"text":[{"text":"    pub fn render<P: Pixel>(&self) -> Renderer<P> {","highlight_start":22,"highlight_end":27}],"label":"required by this bound in `QrCode::render`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Luma<u8>: Element` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:24:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let image = code.render::<Luma<u8>>().build();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Element` is not implemented for `Luma<u8>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `qrcode::render::Pixel` for `Luma<u8>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `QrCode::render`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/qrcode-0.11.2/src/lib.rs:226:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m226\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    pub fn render<P: Pixel>(&self) -> Renderer<P> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `QrCode::render`\u001b[0m\n\n"}
{"message":"the method `build` exists for struct `Renderer<'_, Luma<u8>>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":555,"byte_end":560,"line_start":24,"line_end":24,"column_start":43,"column_end":48,"is_primary":true,"text":[{"text":"    let image = code.render::<Luma<u8>>().build();","highlight_start":43,"highlight_end":48}],"label":"method cannot be called on `Renderer<'_, Luma<u8>>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.24.2/./src/color.rs","byte_start":6799,"byte_end":6841,"line_start":217,"line_end":217,"column_start":1,"column_end":43,"is_primary":false,"text":[{"text":"pub struct $ident<T> (pub [T; $channels]);","highlight_start":1,"highlight_end":43}],"label":"doesn't satisfy `Luma<u8>: Element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.24.2/./src/color.rs","byte_start":10501,"byte_end":11034,"line_start":358,"line_end":370,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"define_colors! {","highlight_start":1,"highlight_end":17},{"text":"    /// RGB colors.","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// For the purpose of color conversion, as well as blending, the implementation of `Pixel`","highlight_start":1,"highlight_end":96},{"text":"    /// assumes an `sRGB` color space of its data.","highlight_start":1,"highlight_end":51},{"text":"    pub struct Rgb<T: Primitive Enlargeable>([T; 3, 0]) = \"RGB\";","highlight_start":1,"highlight_end":65},{"text":"    /// Grayscale colors.","highlight_start":1,"highlight_end":26},{"text":"    pub struct Luma<T: Primitive>([T; 1, 0]) = \"Y\";","highlight_start":1,"highlight_end":52},{"text":"    /// RGB colors + alpha channel","highlight_start":1,"highlight_end":35},{"text":"    pub struct Rgba<T: Primitive Enlargeable>([T; 4, 1]) = \"RGBA\";","highlight_start":1,"highlight_end":67},{"text":"    /// Grayscale colors + alpha channel","highlight_start":1,"highlight_end":41},{"text":"    pub struct LumaA<T: Primitive>([T; 2, 1]) = \"YA\";","highlight_start":1,"highlight_end":54},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"define_colors!","def_site_span":{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.24.2/./src/color.rs","byte_start":6464,"byte_end":10499,"line_start":204,"line_end":356,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! define_colors {","highlight_start":1,"highlight_end":29},{"text":"    {$(","highlight_start":1,"highlight_end":8},{"text":"        $(#[$doc:meta])*","highlight_start":1,"highlight_end":25},{"text":"        pub struct $ident:ident<T: $($bound:ident)*>([T; $channels:expr, $alphas:expr])","highlight_start":1,"highlight_end":88},{"text":"            = $interpretation:literal;","highlight_start":1,"highlight_end":39},{"text":"    )*} => {","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"$( // START Structure definitions","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1},{"text":"$(#[$doc])*","highlight_start":1,"highlight_end":12},{"text":"#[derive(PartialEq, Eq, Clone, Debug, Copy, Hash)]","highlight_start":1,"highlight_end":51},{"text":"#[repr(C)]","highlight_start":1,"highlight_end":11},{"text":"#[allow(missing_docs)]","highlight_start":1,"highlight_end":23},{"text":"pub struct $ident<T> (pub [T; $channels]);","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T: $($bound+)*> Pixel for $ident<T> {","highlight_start":1,"highlight_end":43},{"text":"    type Subpixel = T;","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    const CHANNEL_COUNT: u8 = $channels;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn channels(&self) -> &[T] {","highlight_start":1,"highlight_end":33},{"text":"        &self.0","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn channels_mut(&mut self) -> &mut [T] {","highlight_start":1,"highlight_end":45},{"text":"        &mut self.0","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    const COLOR_MODEL: &'static str = $interpretation;","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn channels4(&self) -> (T, T, T, T) {","highlight_start":1,"highlight_end":42},{"text":"        const CHANNELS: usize = $channels;","highlight_start":1,"highlight_end":43},{"text":"        let mut channels = [T::DEFAULT_MAX_VALUE; 4];","highlight_start":1,"highlight_end":54},{"text":"        channels[0..CHANNELS].copy_from_slice(&self.0);","highlight_start":1,"highlight_end":56},{"text":"        (channels[0], channels[1], channels[2], channels[3])","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn from_channels(a: T, b: T, c: T, d: T,) -> $ident<T> {","highlight_start":1,"highlight_end":61},{"text":"        const CHANNELS: usize = $channels;","highlight_start":1,"highlight_end":43},{"text":"        *<$ident<T> as Pixel>::from_slice(&[a, b, c, d][..CHANNELS])","highlight_start":1,"highlight_end":69},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn from_slice(slice: &[T]) -> &$ident<T> {","highlight_start":1,"highlight_end":47},{"text":"        assert_eq!(slice.len(), $channels);","highlight_start":1,"highlight_end":44},{"text":"        unsafe { &*(slice.as_ptr() as *const $ident<T>) }","highlight_start":1,"highlight_end":58},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    fn from_slice_mut(slice: &mut [T]) -> &mut $ident<T> {","highlight_start":1,"highlight_end":59},{"text":"        assert_eq!(slice.len(), $channels);","highlight_start":1,"highlight_end":44},{"text":"        unsafe { &mut *(slice.as_mut_ptr() as *mut $ident<T>) }","highlight_start":1,"highlight_end":64},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_rgb(&self) -> Rgb<T> {","highlight_start":1,"highlight_end":33},{"text":"        let mut pix = Rgb([Zero::zero(), Zero::zero(), Zero::zero()]);","highlight_start":1,"highlight_end":71},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_rgba(&self) -> Rgba<T> {","highlight_start":1,"highlight_end":35},{"text":"        let mut pix = Rgba([Zero::zero(), Zero::zero(), Zero::zero(), Zero::zero()]);","highlight_start":1,"highlight_end":86},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_luma(&self) -> Luma<T> {","highlight_start":1,"highlight_end":35},{"text":"        let mut pix = Luma([Zero::zero()]);","highlight_start":1,"highlight_end":44},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_luma_alpha(&self) -> LumaA<T> {","highlight_start":1,"highlight_end":42},{"text":"        let mut pix = LumaA([Zero::zero(), Zero::zero()]);","highlight_start":1,"highlight_end":59},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn map<F>(& self, f: F) -> $ident<T> where F: FnMut(T) -> T {","highlight_start":1,"highlight_end":66},{"text":"        let mut this = (*self).clone();","highlight_start":1,"highlight_end":40},{"text":"        this.apply(f);","highlight_start":1,"highlight_end":23},{"text":"        this","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn apply<F>(&mut self, mut f: F) where F: FnMut(T) -> T {","highlight_start":1,"highlight_end":62},{"text":"        for v in &mut self.0 {","highlight_start":1,"highlight_end":31},{"text":"            *v = f(*v)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn map_with_alpha<F, G>(&self, f: F, g: G) -> $ident<T> where F: FnMut(T) -> T, G: FnMut(T) -> T {","highlight_start":1,"highlight_end":103},{"text":"        let mut this = (*self).clone();","highlight_start":1,"highlight_end":40},{"text":"        this.apply_with_alpha(f, g);","highlight_start":1,"highlight_end":37},{"text":"        this","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn apply_with_alpha<F, G>(&mut self, mut f: F, mut g: G) where F: FnMut(T) -> T, G: FnMut(T) -> T {","highlight_start":1,"highlight_end":104},{"text":"        const ALPHA: usize = $channels - $alphas;","highlight_start":1,"highlight_end":50},{"text":"        for v in self.0[..ALPHA].iter_mut() {","highlight_start":1,"highlight_end":46},{"text":"            *v = f(*v)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        // The branch of this match is `const`. This way ensures that no subexpression fails the","highlight_start":1,"highlight_end":97},{"text":"        // `const_err` lint (the expression `self.0[ALPHA]` would).","highlight_start":1,"highlight_end":68},{"text":"        if let Some(v) = self.0.get_mut(ALPHA) {","highlight_start":1,"highlight_end":49},{"text":"            *v = g(*v)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn map2<F>(&self, other: &Self, f: F) -> $ident<T> where F: FnMut(T, T) -> T {","highlight_start":1,"highlight_end":83},{"text":"        let mut this = (*self).clone();","highlight_start":1,"highlight_end":40},{"text":"        this.apply2(other, f);","highlight_start":1,"highlight_end":31},{"text":"        this","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn apply2<F>(&mut self, other: &$ident<T>, mut f: F) where F: FnMut(T, T) -> T {","highlight_start":1,"highlight_end":85},{"text":"        for (a, &b) in self.0.iter_mut().zip(other.0.iter()) {","highlight_start":1,"highlight_end":63},{"text":"            *a = f(*a, b)","highlight_start":1,"highlight_end":26},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn invert(&mut self) {","highlight_start":1,"highlight_end":27},{"text":"        Invert::invert(self)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn blend(&mut self, other: &$ident<T>) {","highlight_start":1,"highlight_end":45},{"text":"        Blend::blend(self, other)","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T> Index<usize> for $ident<T> {","highlight_start":1,"highlight_end":37},{"text":"    type Output = T;","highlight_start":1,"highlight_end":21},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn index(&self, _index: usize) -> &T {","highlight_start":1,"highlight_end":43},{"text":"        &self.0[_index]","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T> IndexMut<usize> for $ident<T> {","highlight_start":1,"highlight_end":40},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn index_mut(&mut self, _index: usize) -> &mut T {","highlight_start":1,"highlight_end":55},{"text":"        &mut self.0[_index]","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T> From<[T; $channels]> for $ident<T> {","highlight_start":1,"highlight_end":45},{"text":"    fn from(c: [T; $channels]) -> Self {","highlight_start":1,"highlight_end":41},{"text":"        Self(c)","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":")* // END Structure definitions","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.24.2/./src/color.rs","byte_start":6799,"byte_end":6841,"line_start":217,"line_end":217,"column_start":1,"column_end":43,"is_primary":false,"text":[{"text":"pub struct $ident<T> (pub [T; $channels]);","highlight_start":1,"highlight_end":43}],"label":"doesn't satisfy `Luma<u8>: qrcode::render::Pixel`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.24.2/./src/color.rs","byte_start":10501,"byte_end":11034,"line_start":358,"line_end":370,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"define_colors! {","highlight_start":1,"highlight_end":17},{"text":"    /// RGB colors.","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// For the purpose of color conversion, as well as blending, the implementation of `Pixel`","highlight_start":1,"highlight_end":96},{"text":"    /// assumes an `sRGB` color space of its data.","highlight_start":1,"highlight_end":51},{"text":"    pub struct Rgb<T: Primitive Enlargeable>([T; 3, 0]) = \"RGB\";","highlight_start":1,"highlight_end":65},{"text":"    /// Grayscale colors.","highlight_start":1,"highlight_end":26},{"text":"    pub struct Luma<T: Primitive>([T; 1, 0]) = \"Y\";","highlight_start":1,"highlight_end":52},{"text":"    /// RGB colors + alpha channel","highlight_start":1,"highlight_end":35},{"text":"    pub struct Rgba<T: Primitive Enlargeable>([T; 4, 1]) = \"RGBA\";","highlight_start":1,"highlight_end":67},{"text":"    /// Grayscale colors + alpha channel","highlight_start":1,"highlight_end":41},{"text":"    pub struct LumaA<T: Primitive>([T; 2, 1]) = \"YA\";","highlight_start":1,"highlight_end":54},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"define_colors!","def_site_span":{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.24.2/./src/color.rs","byte_start":6464,"byte_end":10499,"line_start":204,"line_end":356,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! define_colors {","highlight_start":1,"highlight_end":29},{"text":"    {$(","highlight_start":1,"highlight_end":8},{"text":"        $(#[$doc:meta])*","highlight_start":1,"highlight_end":25},{"text":"        pub struct $ident:ident<T: $($bound:ident)*>([T; $channels:expr, $alphas:expr])","highlight_start":1,"highlight_end":88},{"text":"            = $interpretation:literal;","highlight_start":1,"highlight_end":39},{"text":"    )*} => {","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"$( // START Structure definitions","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1},{"text":"$(#[$doc])*","highlight_start":1,"highlight_end":12},{"text":"#[derive(PartialEq, Eq, Clone, Debug, Copy, Hash)]","highlight_start":1,"highlight_end":51},{"text":"#[repr(C)]","highlight_start":1,"highlight_end":11},{"text":"#[allow(missing_docs)]","highlight_start":1,"highlight_end":23},{"text":"pub struct $ident<T> (pub [T; $channels]);","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T: $($bound+)*> Pixel for $ident<T> {","highlight_start":1,"highlight_end":43},{"text":"    type Subpixel = T;","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    const CHANNEL_COUNT: u8 = $channels;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn channels(&self) -> &[T] {","highlight_start":1,"highlight_end":33},{"text":"        &self.0","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn channels_mut(&mut self) -> &mut [T] {","highlight_start":1,"highlight_end":45},{"text":"        &mut self.0","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    const COLOR_MODEL: &'static str = $interpretation;","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn channels4(&self) -> (T, T, T, T) {","highlight_start":1,"highlight_end":42},{"text":"        const CHANNELS: usize = $channels;","highlight_start":1,"highlight_end":43},{"text":"        let mut channels = [T::DEFAULT_MAX_VALUE; 4];","highlight_start":1,"highlight_end":54},{"text":"        channels[0..CHANNELS].copy_from_slice(&self.0);","highlight_start":1,"highlight_end":56},{"text":"        (channels[0], channels[1], channels[2], channels[3])","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn from_channels(a: T, b: T, c: T, d: T,) -> $ident<T> {","highlight_start":1,"highlight_end":61},{"text":"        const CHANNELS: usize = $channels;","highlight_start":1,"highlight_end":43},{"text":"        *<$ident<T> as Pixel>::from_slice(&[a, b, c, d][..CHANNELS])","highlight_start":1,"highlight_end":69},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn from_slice(slice: &[T]) -> &$ident<T> {","highlight_start":1,"highlight_end":47},{"text":"        assert_eq!(slice.len(), $channels);","highlight_start":1,"highlight_end":44},{"text":"        unsafe { &*(slice.as_ptr() as *const $ident<T>) }","highlight_start":1,"highlight_end":58},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    fn from_slice_mut(slice: &mut [T]) -> &mut $ident<T> {","highlight_start":1,"highlight_end":59},{"text":"        assert_eq!(slice.len(), $channels);","highlight_start":1,"highlight_end":44},{"text":"        unsafe { &mut *(slice.as_mut_ptr() as *mut $ident<T>) }","highlight_start":1,"highlight_end":64},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_rgb(&self) -> Rgb<T> {","highlight_start":1,"highlight_end":33},{"text":"        let mut pix = Rgb([Zero::zero(), Zero::zero(), Zero::zero()]);","highlight_start":1,"highlight_end":71},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_rgba(&self) -> Rgba<T> {","highlight_start":1,"highlight_end":35},{"text":"        let mut pix = Rgba([Zero::zero(), Zero::zero(), Zero::zero(), Zero::zero()]);","highlight_start":1,"highlight_end":86},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_luma(&self) -> Luma<T> {","highlight_start":1,"highlight_end":35},{"text":"        let mut pix = Luma([Zero::zero()]);","highlight_start":1,"highlight_end":44},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_luma_alpha(&self) -> LumaA<T> {","highlight_start":1,"highlight_end":42},{"text":"        let mut pix = LumaA([Zero::zero(), Zero::zero()]);","highlight_start":1,"highlight_end":59},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn map<F>(& self, f: F) -> $ident<T> where F: FnMut(T) -> T {","highlight_start":1,"highlight_end":66},{"text":"        let mut this = (*self).clone();","highlight_start":1,"highlight_end":40},{"text":"        this.apply(f);","highlight_start":1,"highlight_end":23},{"text":"        this","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn apply<F>(&mut self, mut f: F) where F: FnMut(T) -> T {","highlight_start":1,"highlight_end":62},{"text":"        for v in &mut self.0 {","highlight_start":1,"highlight_end":31},{"text":"            *v = f(*v)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn map_with_alpha<F, G>(&self, f: F, g: G) -> $ident<T> where F: FnMut(T) -> T, G: FnMut(T) -> T {","highlight_start":1,"highlight_end":103},{"text":"        let mut this = (*self).clone();","highlight_start":1,"highlight_end":40},{"text":"        this.apply_with_alpha(f, g);","highlight_start":1,"highlight_end":37},{"text":"        this","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn apply_with_alpha<F, G>(&mut self, mut f: F, mut g: G) where F: FnMut(T) -> T, G: FnMut(T) -> T {","highlight_start":1,"highlight_end":104},{"text":"        const ALPHA: usize = $channels - $alphas;","highlight_start":1,"highlight_end":50},{"text":"        for v in self.0[..ALPHA].iter_mut() {","highlight_start":1,"highlight_end":46},{"text":"            *v = f(*v)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        // The branch of this match is `const`. This way ensures that no subexpression fails the","highlight_start":1,"highlight_end":97},{"text":"        // `const_err` lint (the expression `self.0[ALPHA]` would).","highlight_start":1,"highlight_end":68},{"text":"        if let Some(v) = self.0.get_mut(ALPHA) {","highlight_start":1,"highlight_end":49},{"text":"            *v = g(*v)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn map2<F>(&self, other: &Self, f: F) -> $ident<T> where F: FnMut(T, T) -> T {","highlight_start":1,"highlight_end":83},{"text":"        let mut this = (*self).clone();","highlight_start":1,"highlight_end":40},{"text":"        this.apply2(other, f);","highlight_start":1,"highlight_end":31},{"text":"        this","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn apply2<F>(&mut self, other: &$ident<T>, mut f: F) where F: FnMut(T, T) -> T {","highlight_start":1,"highlight_end":85},{"text":"        for (a, &b) in self.0.iter_mut().zip(other.0.iter()) {","highlight_start":1,"highlight_end":63},{"text":"            *a = f(*a, b)","highlight_start":1,"highlight_end":26},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn invert(&mut self) {","highlight_start":1,"highlight_end":27},{"text":"        Invert::invert(self)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn blend(&mut self, other: &$ident<T>) {","highlight_start":1,"highlight_end":45},{"text":"        Blend::blend(self, other)","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T> Index<usize> for $ident<T> {","highlight_start":1,"highlight_end":37},{"text":"    type Output = T;","highlight_start":1,"highlight_end":21},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn index(&self, _index: usize) -> &T {","highlight_start":1,"highlight_end":43},{"text":"        &self.0[_index]","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T> IndexMut<usize> for $ident<T> {","highlight_start":1,"highlight_end":40},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn index_mut(&mut self, _index: usize) -> &mut T {","highlight_start":1,"highlight_end":55},{"text":"        &mut self.0[_index]","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T> From<[T; $channels]> for $ident<T> {","highlight_start":1,"highlight_end":45},{"text":"    fn from(c: [T; $channels]) -> Self {","highlight_start":1,"highlight_end":41},{"text":"        Self(c)","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":")* // END Structure definitions","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following trait bounds were not satisfied:\n`Luma<u8>: qrcode::render::Pixel`\n`Luma<u8>: Element`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `build` exists for struct `Renderer<'_, Luma<u8>>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:24:43\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    let image = code.render::<Luma<u8>>().build();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called on `Renderer<'_, Luma<u8>>` due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.24.2/./src/color.rs:358:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m358\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdefine_colors! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m359\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// RGB colors.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m360\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m361\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// For the purpose of color conversion, as well as blending, the implementation of `Pixel`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m369\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct LumaA<T: Primitive>([T; 2, 1]) = \"YA\";\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m370\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `Luma<u8>: Element`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `Luma<u8>: qrcode::render::Pixel`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `Luma<u8>: qrcode::render::Pixel`\u001b[0m\n\u001b[0m            `Luma<u8>: Element`\u001b[0m\n\n"}
{"message":"aborting due to 2 previous errors; 6 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 2 previous errors; 6 warnings emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0277, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0277, E0599.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
