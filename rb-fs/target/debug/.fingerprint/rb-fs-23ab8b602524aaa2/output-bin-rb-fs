{"message":"mismatched closing delimiter: `)`","code":null,"level":"error","spans":[{"file_name":"src/main.rs","byte_start":504,"byte_end":505,"line_start":23,"line_end":23,"column_start":42,"column_end":43,"is_primary":true,"text":[{"text":"    let code = QrCode::new(encode_disk[..).unwrap();","highlight_start":42,"highlight_end":43}],"label":"mismatched closing delimiter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":489,"byte_end":490,"line_start":23,"line_end":23,"column_start":27,"column_end":28,"is_primary":false,"text":[{"text":"    let code = QrCode::new(encode_disk[..).unwrap();","highlight_start":27,"highlight_end":28}],"label":"closing delimiter possibly meant for this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":501,"byte_end":502,"line_start":23,"line_end":23,"column_start":39,"column_end":40,"is_primary":true,"text":[{"text":"    let code = QrCode::new(encode_disk[..).unwrap();","highlight_start":39,"highlight_end":40}],"label":"unclosed delimiter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: mismatched closing delimiter: `)`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:23:39\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let code = QrCode::new(encode_disk[..).unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmismatched closing delimiter\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munclosed delimiter\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mclosing delimiter possibly meant for this\u001b[0m\n\n"}
{"message":"unused import: `ReplyOpen`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/mkfs.rs","byte_start":80,"byte_end":89,"line_start":1,"line_end":1,"column_start":81,"column_end":90,"is_primary":true,"text":[{"text":"use fuse::{Filesystem, Request, ReplyCreate, ReplyEmpty, ReplyAttr, ReplyEntry, ReplyOpen, ReplyStatfs,ReplyData, ReplyDirectory, ReplyWrite, FileType, FileAttr};","highlight_start":81,"highlight_end":90}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/mkfs.rs","byte_start":78,"byte_end":89,"line_start":1,"line_end":1,"column_start":79,"column_end":90,"is_primary":true,"text":[{"text":"use fuse::{Filesystem, Request, ReplyCreate, ReplyEmpty, ReplyAttr, ReplyEntry, ReplyOpen, ReplyStatfs,ReplyData, ReplyDirectory, ReplyWrite, FileType, FileAttr};","highlight_start":79,"highlight_end":90}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `ReplyOpen`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/mkfs.rs:1:81\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse fuse::{Filesystem, Request, ReplyCreate, ReplyEmpty, ReplyAttr, ReplyEntry, ReplyOpen, ReplyStatfs,ReplyData, ReplyDirectory, ReplyWr\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused imports: `EISDIR`, `ENOSPC`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/mkfs.rs","byte_start":195,"byte_end":201,"line_start":2,"line_end":2,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"use libc::{ENOSYS, ENOENT, EIO, EISDIR, ENOSPC};","highlight_start":33,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/mkfs.rs","byte_start":203,"byte_end":209,"line_start":2,"line_end":2,"column_start":41,"column_end":47,"is_primary":true,"text":[{"text":"use libc::{ENOSYS, ENOENT, EIO, EISDIR, ENOSPC};","highlight_start":41,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/mkfs.rs","byte_start":193,"byte_end":209,"line_start":2,"line_end":2,"column_start":31,"column_end":47,"is_primary":true,"text":[{"text":"use libc::{ENOSYS, ENOENT, EIO, EISDIR, ENOSPC};","highlight_start":31,"highlight_end":47}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `EISDIR`, `ENOSPC`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/mkfs.rs:2:33\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse libc::{ENOSYS, ENOENT, EIO, EISDIR, ENOSPC};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\n\n"}
{"message":"unused import: `crate::mkfs`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/mkfs.rs","byte_start":251,"byte_end":262,"line_start":5,"line_end":5,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"use crate::mkfs;","highlight_start":5,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/mkfs.rs","byte_start":247,"byte_end":263,"line_start":5,"line_end":5,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"use crate::mkfs;","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `crate::mkfs`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/mkfs.rs:5:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse crate::mkfs;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"type `Mem_block` should have an upper camel case name","code":{"code":"non_camel_case_types","explanation":null},"level":"warning","spans":[{"file_name":"src/mkfs.rs","byte_start":1237,"byte_end":1246,"line_start":40,"line_end":40,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Mem_block {","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(non_camel_case_types)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"convert the identifier to upper camel case","code":null,"level":"help","spans":[{"file_name":"src/mkfs.rs","byte_start":1237,"byte_end":1246,"line_start":40,"line_end":40,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Mem_block {","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":"MemBlock","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: type `Mem_block` should have an upper camel case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/mkfs.rs:40:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct Mem_block {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to upper camel case: `MemBlock`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(non_camel_case_types)]` on by default\u001b[0m\n\n"}
{"message":"type `Rb_fs` should have an upper camel case name","code":{"code":"non_camel_case_types","explanation":null},"level":"warning","spans":[{"file_name":"src/mkfs.rs","byte_start":6950,"byte_end":6955,"line_start":219,"line_end":219,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"pub struct Rb_fs {","highlight_start":12,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to upper camel case","code":null,"level":"help","spans":[{"file_name":"src/mkfs.rs","byte_start":6950,"byte_end":6955,"line_start":219,"line_end":219,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"pub struct Rb_fs {","highlight_start":12,"highlight_end":17}],"label":null,"suggested_replacement":"RbFs","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: type `Rb_fs` should have an upper camel case name\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/mkfs.rs:219:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct Rb_fs {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to upper camel case: `RbFs`\u001b[0m\n\n"}
{"message":"unused import: `std::ffi::OsStr`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":43,"byte_end":58,"line_start":4,"line_end":4,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use std::ffi::OsStr;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":39,"byte_end":59,"line_start":4,"line_end":4,"column_start":1,"column_end":21,"is_primary":true,"text":[{"text":"use std::ffi::OsStr;","highlight_start":1,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::ffi::OsStr`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:4:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse std::ffi::OsStr;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"the size for values of type `[u8]` cannot be known at compilation time","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":490,"byte_end":505,"line_start":23,"line_end":23,"column_start":28,"column_end":43,"is_primary":true,"text":[{"text":"    let code = QrCode::new(encode_disk[..).unwrap();","highlight_start":28,"highlight_end":43}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":478,"byte_end":489,"line_start":23,"line_end":23,"column_start":16,"column_end":27,"is_primary":false,"text":[{"text":"    let code = QrCode::new(encode_disk[..).unwrap();","highlight_start":16,"highlight_end":27}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sized` is not implemented for `[u8]`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QrCode::new`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":"required by a bound in this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/qrcode-0.11.2/src/lib.rs","byte_start":1873,"byte_end":1874,"line_start":71,"line_end":71,"column_start":16,"column_end":17,"is_primary":true,"text":[{"text":"    pub fn new<D: AsRef<[u8]>>(data: D) -> QrResult<Self> {","highlight_start":16,"highlight_end":17}],"label":"required by this bound in `QrCode::new`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the size for values of type `[u8]` cannot be known at compilation time\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:23:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let code = QrCode::new(encode_disk[..).unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdoesn't have a size known at compile-time\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sized` is not implemented for `[u8]`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `QrCode::new`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/qrcode-0.11.2/src/lib.rs:71:16\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    pub fn new<D: AsRef<[u8]>>(data: D) -> QrResult<Self> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `QrCode::new`\u001b[0m\n\n"}
{"message":"the trait bound `Luma<u8>: Element` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":537,"byte_end":543,"line_start":24,"line_end":24,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"    let image = code.render::<Luma<u8>>().build();","highlight_start":22,"highlight_end":28}],"label":"the trait `Element` is not implemented for `Luma<u8>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required because of the requirements on the impl of `qrcode::render::Pixel` for `Luma<u8>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QrCode::render`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":"required by a bound in this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/qrcode-0.11.2/src/lib.rs","byte_start":8173,"byte_end":8178,"line_start":226,"line_end":226,"column_start":22,"column_end":27,"is_primary":true,"text":[{"text":"    pub fn render<P: Pixel>(&self) -> Renderer<P> {","highlight_start":22,"highlight_end":27}],"label":"required by this bound in `QrCode::render`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Luma<u8>: Element` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:24:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let image = code.render::<Luma<u8>>().build();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Element` is not implemented for `Luma<u8>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `qrcode::render::Pixel` for `Luma<u8>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `QrCode::render`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/qrcode-0.11.2/src/lib.rs:226:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m226\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    pub fn render<P: Pixel>(&self) -> Renderer<P> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `QrCode::render`\u001b[0m\n\n"}
{"message":"the method `build` exists for struct `Renderer<'_, Luma<u8>>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":558,"byte_end":563,"line_start":24,"line_end":24,"column_start":43,"column_end":48,"is_primary":true,"text":[{"text":"    let image = code.render::<Luma<u8>>().build();","highlight_start":43,"highlight_end":48}],"label":"method cannot be called on `Renderer<'_, Luma<u8>>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.17.0/./src/color.rs","byte_start":1535,"byte_end":1566,"line_start":64,"line_end":64,"column_start":1,"column_end":32,"is_primary":false,"text":[{"text":"pub struct $ident<T: Primitive> { pub data: [T; $channels] }","highlight_start":1,"highlight_end":32}],"label":"doesn't satisfy `Luma<u8>: Element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.17.0/./src/color.rs","byte_start":5340,"byte_end":5608,"line_start":208,"line_end":213,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"define_colors! {","highlight_start":1,"highlight_end":17},{"text":"    Rgb, 3, 0, \"RGB\", RGB, #[doc = \"RGB colors\"];","highlight_start":1,"highlight_end":50},{"text":"    Luma, 1, 0, \"Y\", Gray, #[doc = \"Grayscale colors\"];","highlight_start":1,"highlight_end":56},{"text":"    Rgba, 4, 1, \"RGBA\", RGBA, #[doc = \"RGB colors + alpha channel\"];","highlight_start":1,"highlight_end":69},{"text":"    LumaA, 2, 1, \"YA\", GrayA, #[doc = \"Grayscale colors + alpha channel\"];","highlight_start":1,"highlight_end":75},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"define_colors!","def_site_span":{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.17.0/./src/color.rs","byte_start":1205,"byte_end":5338,"line_start":48,"line_end":206,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! define_colors {","highlight_start":1,"highlight_end":29},{"text":"    {$(","highlight_start":1,"highlight_end":8},{"text":"        $ident:ident,","highlight_start":1,"highlight_end":22},{"text":"        $channels: expr,","highlight_start":1,"highlight_end":25},{"text":"        $alphas: expr,","highlight_start":1,"highlight_end":23},{"text":"        $interpretation: expr,","highlight_start":1,"highlight_end":31},{"text":"        $color_type: ident,","highlight_start":1,"highlight_end":28},{"text":"        #[$doc:meta];","highlight_start":1,"highlight_end":22},{"text":"    )*} => {","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"$( // START Structure definitions","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[$doc]","highlight_start":1,"highlight_end":8},{"text":"#[derive(PartialEq, Eq, Clone, Debug, Copy, Hash)]","highlight_start":1,"highlight_end":51},{"text":"#[repr(C)]","highlight_start":1,"highlight_end":11},{"text":"#[allow(missing_docs)]","highlight_start":1,"highlight_end":23},{"text":"pub struct $ident<T: Primitive> { pub data: [T; $channels] }","highlight_start":1,"highlight_end":61},{"text":"#[allow(non_snake_case, missing_docs)]","highlight_start":1,"highlight_end":39},{"text":"pub fn $ident<T: Primitive>(data: [T; $channels]) -> $ident<T> {","highlight_start":1,"highlight_end":65},{"text":"    $ident {","highlight_start":1,"highlight_end":13},{"text":"        data: data","highlight_start":1,"highlight_end":19},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T: Primitive + 'static> Pixel for $ident<T> {","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    type Subpixel = T;","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn channel_count() -> u8 {","highlight_start":1,"highlight_end":31},{"text":"        $channels","highlight_start":1,"highlight_end":18},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    fn color_model() -> &'static str {","highlight_start":1,"highlight_end":39},{"text":"        $interpretation","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    fn color_type() -> ColorType {","highlight_start":1,"highlight_end":35},{"text":"        ColorType::$color_type(mem::size_of::<T>() as u8 * 8)","highlight_start":1,"highlight_end":62},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn channels(&self) -> &[T] {","highlight_start":1,"highlight_end":33},{"text":"        &self.data","highlight_start":1,"highlight_end":19},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn channels_mut(&mut self) -> &mut [T] {","highlight_start":1,"highlight_end":45},{"text":"        &mut self.data","highlight_start":1,"highlight_end":23},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[allow(trivial_casts)]","highlight_start":1,"highlight_end":28},{"text":"    fn channels4(&self) -> (T, T, T, T) {","highlight_start":1,"highlight_end":42},{"text":"        let mut channels = [T::max_value(); 4];","highlight_start":1,"highlight_end":48},{"text":"        channels[0..$channels].copy_from_slice(&self.data);","highlight_start":1,"highlight_end":60},{"text":"        (channels[0], channels[1], channels[2], channels[3])","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn from_channels(a: T, b: T, c: T, d: T,) -> $ident<T> {","highlight_start":1,"highlight_end":61},{"text":"        *<$ident<T> as Pixel>::from_slice(&[a, b, c, d][..$channels])","highlight_start":1,"highlight_end":70},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn from_slice(slice: &[T]) -> &$ident<T> {","highlight_start":1,"highlight_end":47},{"text":"        assert_eq!(slice.len(), $channels);","highlight_start":1,"highlight_end":44},{"text":"        unsafe { &*(slice.as_ptr() as *const $ident<T>) }","highlight_start":1,"highlight_end":58},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    fn from_slice_mut(slice: &mut [T]) -> &mut $ident<T> {","highlight_start":1,"highlight_end":59},{"text":"        assert_eq!(slice.len(), $channels);","highlight_start":1,"highlight_end":44},{"text":"        unsafe { &mut *(slice.as_ptr() as *mut $ident<T>) }","highlight_start":1,"highlight_end":60},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_rgb(&self) -> Rgb<T> {","highlight_start":1,"highlight_end":33},{"text":"        let mut pix = Rgb {data: [Zero::zero(), Zero::zero(), Zero::zero()]};","highlight_start":1,"highlight_end":78},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_rgba(&self) -> Rgba<T> {","highlight_start":1,"highlight_end":35},{"text":"        let mut pix = Rgba {data: [Zero::zero(), Zero::zero(), Zero::zero(), Zero::zero()]};","highlight_start":1,"highlight_end":93},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_luma(&self) -> Luma<T> {","highlight_start":1,"highlight_end":35},{"text":"        let mut pix = Luma {data: [Zero::zero()]};","highlight_start":1,"highlight_end":51},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_luma_alpha(&self) -> LumaA<T> {","highlight_start":1,"highlight_end":42},{"text":"        let mut pix = LumaA {data: [Zero::zero(), Zero::zero()]};","highlight_start":1,"highlight_end":66},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn map<F>(& self, f: F) -> $ident<T> where F: FnMut(T) -> T {","highlight_start":1,"highlight_end":66},{"text":"        let mut this = (*self).clone();","highlight_start":1,"highlight_end":40},{"text":"        this.apply(f);","highlight_start":1,"highlight_end":23},{"text":"        this","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn apply<F>(&mut self, mut f: F) where F: FnMut(T) -> T {","highlight_start":1,"highlight_end":62},{"text":"        for v in &mut self.data {","highlight_start":1,"highlight_end":34},{"text":"            *v = f(*v)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn map_with_alpha<F, G>(&self, f: F, g: G) -> $ident<T> where F: FnMut(T) -> T, G: FnMut(T) -> T {","highlight_start":1,"highlight_end":103},{"text":"        let mut this = (*self).clone();","highlight_start":1,"highlight_end":40},{"text":"        this.apply_with_alpha(f, g);","highlight_start":1,"highlight_end":37},{"text":"        this","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[allow(trivial_casts)]","highlight_start":1,"highlight_end":28},{"text":"    fn apply_with_alpha<F, G>(&mut self, mut f: F, mut g: G) where F: FnMut(T) -> T, G: FnMut(T) -> T {","highlight_start":1,"highlight_end":104},{"text":"        for v in self.data[..$channels as usize-$alphas as usize].iter_mut() {","highlight_start":1,"highlight_end":79},{"text":"            *v = f(*v)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        if $alphas as usize != 0 {","highlight_start":1,"highlight_end":35},{"text":"            let v = &mut self.data[$channels as usize-$alphas as usize-1];","highlight_start":1,"highlight_end":75},{"text":"            *v = g(*v)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn map2<F>(&self, other: &Self, f: F) -> $ident<T> where F: FnMut(T, T) -> T {","highlight_start":1,"highlight_end":83},{"text":"        let mut this = (*self).clone();","highlight_start":1,"highlight_end":40},{"text":"        this.apply2(other, f);","highlight_start":1,"highlight_end":31},{"text":"        this","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn apply2<F>(&mut self, other: &$ident<T>, mut f: F) where F: FnMut(T, T) -> T {","highlight_start":1,"highlight_end":85},{"text":"        for (a, &b) in self.data.iter_mut().zip(other.data.iter()) {","highlight_start":1,"highlight_end":69},{"text":"            *a = f(*a, b)","highlight_start":1,"highlight_end":26},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn invert(&mut self) {","highlight_start":1,"highlight_end":27},{"text":"        Invert::invert(self)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn blend(&mut self, other: &$ident<T>) {","highlight_start":1,"highlight_end":45},{"text":"        Blend::blend(self, other)","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T: Primitive> Index<usize> for $ident<T> {","highlight_start":1,"highlight_end":48},{"text":"    type Output = T;","highlight_start":1,"highlight_end":21},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn index(&self, _index: usize) -> &T {","highlight_start":1,"highlight_end":43},{"text":"        &self.data[_index]","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T: Primitive> IndexMut<usize> for $ident<T> {","highlight_start":1,"highlight_end":51},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn index_mut(&mut self, _index: usize) -> &mut T {","highlight_start":1,"highlight_end":55},{"text":"        &mut self.data[_index]","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":")* // END Structure definitions","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.17.0/./src/color.rs","byte_start":1535,"byte_end":1566,"line_start":64,"line_end":64,"column_start":1,"column_end":32,"is_primary":false,"text":[{"text":"pub struct $ident<T: Primitive> { pub data: [T; $channels] }","highlight_start":1,"highlight_end":32}],"label":"doesn't satisfy `Luma<u8>: qrcode::render::Pixel`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.17.0/./src/color.rs","byte_start":5340,"byte_end":5608,"line_start":208,"line_end":213,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"define_colors! {","highlight_start":1,"highlight_end":17},{"text":"    Rgb, 3, 0, \"RGB\", RGB, #[doc = \"RGB colors\"];","highlight_start":1,"highlight_end":50},{"text":"    Luma, 1, 0, \"Y\", Gray, #[doc = \"Grayscale colors\"];","highlight_start":1,"highlight_end":56},{"text":"    Rgba, 4, 1, \"RGBA\", RGBA, #[doc = \"RGB colors + alpha channel\"];","highlight_start":1,"highlight_end":69},{"text":"    LumaA, 2, 1, \"YA\", GrayA, #[doc = \"Grayscale colors + alpha channel\"];","highlight_start":1,"highlight_end":75},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"define_colors!","def_site_span":{"file_name":"/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.17.0/./src/color.rs","byte_start":1205,"byte_end":5338,"line_start":48,"line_end":206,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! define_colors {","highlight_start":1,"highlight_end":29},{"text":"    {$(","highlight_start":1,"highlight_end":8},{"text":"        $ident:ident,","highlight_start":1,"highlight_end":22},{"text":"        $channels: expr,","highlight_start":1,"highlight_end":25},{"text":"        $alphas: expr,","highlight_start":1,"highlight_end":23},{"text":"        $interpretation: expr,","highlight_start":1,"highlight_end":31},{"text":"        $color_type: ident,","highlight_start":1,"highlight_end":28},{"text":"        #[$doc:meta];","highlight_start":1,"highlight_end":22},{"text":"    )*} => {","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"$( // START Structure definitions","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[$doc]","highlight_start":1,"highlight_end":8},{"text":"#[derive(PartialEq, Eq, Clone, Debug, Copy, Hash)]","highlight_start":1,"highlight_end":51},{"text":"#[repr(C)]","highlight_start":1,"highlight_end":11},{"text":"#[allow(missing_docs)]","highlight_start":1,"highlight_end":23},{"text":"pub struct $ident<T: Primitive> { pub data: [T; $channels] }","highlight_start":1,"highlight_end":61},{"text":"#[allow(non_snake_case, missing_docs)]","highlight_start":1,"highlight_end":39},{"text":"pub fn $ident<T: Primitive>(data: [T; $channels]) -> $ident<T> {","highlight_start":1,"highlight_end":65},{"text":"    $ident {","highlight_start":1,"highlight_end":13},{"text":"        data: data","highlight_start":1,"highlight_end":19},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T: Primitive + 'static> Pixel for $ident<T> {","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    type Subpixel = T;","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn channel_count() -> u8 {","highlight_start":1,"highlight_end":31},{"text":"        $channels","highlight_start":1,"highlight_end":18},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    fn color_model() -> &'static str {","highlight_start":1,"highlight_end":39},{"text":"        $interpretation","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    fn color_type() -> ColorType {","highlight_start":1,"highlight_end":35},{"text":"        ColorType::$color_type(mem::size_of::<T>() as u8 * 8)","highlight_start":1,"highlight_end":62},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn channels(&self) -> &[T] {","highlight_start":1,"highlight_end":33},{"text":"        &self.data","highlight_start":1,"highlight_end":19},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn channels_mut(&mut self) -> &mut [T] {","highlight_start":1,"highlight_end":45},{"text":"        &mut self.data","highlight_start":1,"highlight_end":23},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[allow(trivial_casts)]","highlight_start":1,"highlight_end":28},{"text":"    fn channels4(&self) -> (T, T, T, T) {","highlight_start":1,"highlight_end":42},{"text":"        let mut channels = [T::max_value(); 4];","highlight_start":1,"highlight_end":48},{"text":"        channels[0..$channels].copy_from_slice(&self.data);","highlight_start":1,"highlight_end":60},{"text":"        (channels[0], channels[1], channels[2], channels[3])","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn from_channels(a: T, b: T, c: T, d: T,) -> $ident<T> {","highlight_start":1,"highlight_end":61},{"text":"        *<$ident<T> as Pixel>::from_slice(&[a, b, c, d][..$channels])","highlight_start":1,"highlight_end":70},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn from_slice(slice: &[T]) -> &$ident<T> {","highlight_start":1,"highlight_end":47},{"text":"        assert_eq!(slice.len(), $channels);","highlight_start":1,"highlight_end":44},{"text":"        unsafe { &*(slice.as_ptr() as *const $ident<T>) }","highlight_start":1,"highlight_end":58},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    fn from_slice_mut(slice: &mut [T]) -> &mut $ident<T> {","highlight_start":1,"highlight_end":59},{"text":"        assert_eq!(slice.len(), $channels);","highlight_start":1,"highlight_end":44},{"text":"        unsafe { &mut *(slice.as_ptr() as *mut $ident<T>) }","highlight_start":1,"highlight_end":60},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_rgb(&self) -> Rgb<T> {","highlight_start":1,"highlight_end":33},{"text":"        let mut pix = Rgb {data: [Zero::zero(), Zero::zero(), Zero::zero()]};","highlight_start":1,"highlight_end":78},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_rgba(&self) -> Rgba<T> {","highlight_start":1,"highlight_end":35},{"text":"        let mut pix = Rgba {data: [Zero::zero(), Zero::zero(), Zero::zero(), Zero::zero()]};","highlight_start":1,"highlight_end":93},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_luma(&self) -> Luma<T> {","highlight_start":1,"highlight_end":35},{"text":"        let mut pix = Luma {data: [Zero::zero()]};","highlight_start":1,"highlight_end":51},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn to_luma_alpha(&self) -> LumaA<T> {","highlight_start":1,"highlight_end":42},{"text":"        let mut pix = LumaA {data: [Zero::zero(), Zero::zero()]};","highlight_start":1,"highlight_end":66},{"text":"        pix.from_color(self);","highlight_start":1,"highlight_end":30},{"text":"        pix","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn map<F>(& self, f: F) -> $ident<T> where F: FnMut(T) -> T {","highlight_start":1,"highlight_end":66},{"text":"        let mut this = (*self).clone();","highlight_start":1,"highlight_end":40},{"text":"        this.apply(f);","highlight_start":1,"highlight_end":23},{"text":"        this","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn apply<F>(&mut self, mut f: F) where F: FnMut(T) -> T {","highlight_start":1,"highlight_end":62},{"text":"        for v in &mut self.data {","highlight_start":1,"highlight_end":34},{"text":"            *v = f(*v)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn map_with_alpha<F, G>(&self, f: F, g: G) -> $ident<T> where F: FnMut(T) -> T, G: FnMut(T) -> T {","highlight_start":1,"highlight_end":103},{"text":"        let mut this = (*self).clone();","highlight_start":1,"highlight_end":40},{"text":"        this.apply_with_alpha(f, g);","highlight_start":1,"highlight_end":37},{"text":"        this","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[allow(trivial_casts)]","highlight_start":1,"highlight_end":28},{"text":"    fn apply_with_alpha<F, G>(&mut self, mut f: F, mut g: G) where F: FnMut(T) -> T, G: FnMut(T) -> T {","highlight_start":1,"highlight_end":104},{"text":"        for v in self.data[..$channels as usize-$alphas as usize].iter_mut() {","highlight_start":1,"highlight_end":79},{"text":"            *v = f(*v)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        if $alphas as usize != 0 {","highlight_start":1,"highlight_end":35},{"text":"            let v = &mut self.data[$channels as usize-$alphas as usize-1];","highlight_start":1,"highlight_end":75},{"text":"            *v = g(*v)","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn map2<F>(&self, other: &Self, f: F) -> $ident<T> where F: FnMut(T, T) -> T {","highlight_start":1,"highlight_end":83},{"text":"        let mut this = (*self).clone();","highlight_start":1,"highlight_end":40},{"text":"        this.apply2(other, f);","highlight_start":1,"highlight_end":31},{"text":"        this","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn apply2<F>(&mut self, other: &$ident<T>, mut f: F) where F: FnMut(T, T) -> T {","highlight_start":1,"highlight_end":85},{"text":"        for (a, &b) in self.data.iter_mut().zip(other.data.iter()) {","highlight_start":1,"highlight_end":69},{"text":"            *a = f(*a, b)","highlight_start":1,"highlight_end":26},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn invert(&mut self) {","highlight_start":1,"highlight_end":27},{"text":"        Invert::invert(self)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn blend(&mut self, other: &$ident<T>) {","highlight_start":1,"highlight_end":45},{"text":"        Blend::blend(self, other)","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T: Primitive> Index<usize> for $ident<T> {","highlight_start":1,"highlight_end":48},{"text":"    type Output = T;","highlight_start":1,"highlight_end":21},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn index(&self, _index: usize) -> &T {","highlight_start":1,"highlight_end":43},{"text":"        &self.data[_index]","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl<T: Primitive> IndexMut<usize> for $ident<T> {","highlight_start":1,"highlight_end":51},{"text":"    #[inline(always)]","highlight_start":1,"highlight_end":22},{"text":"    fn index_mut(&mut self, _index: usize) -> &mut T {","highlight_start":1,"highlight_end":55},{"text":"        &mut self.data[_index]","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":")* // END Structure definitions","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following trait bounds were not satisfied:\n`Luma<u8>: qrcode::render::Pixel`\n`Luma<u8>: Element`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `build` exists for struct `Renderer<'_, Luma<u8>>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:24:43\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    let image = code.render::<Luma<u8>>().build();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called on `Renderer<'_, Luma<u8>>` due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/bryan/.cargo/registry/src/github.com-1ecc6299db9ec823/image-0.17.0/./src/color.rs:208:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdefine_colors! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m209\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Rgb, 3, 0, \"RGB\", RGB, #[doc = \"RGB colors\"];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m210\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Luma, 1, 0, \"Y\", Gray, #[doc = \"Grayscale colors\"];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Rgba, 4, 1, \"RGBA\", RGBA, #[doc = \"RGB colors + alpha channel\"];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    LumaA, 2, 1, \"YA\", GrayA, #[doc = \"Grayscale colors + alpha channel\"];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `Luma<u8>: Element`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `Luma<u8>: qrcode::render::Pixel`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `Luma<u8>: qrcode::render::Pixel`\u001b[0m\n\u001b[0m            `Luma<u8>: Element`\u001b[0m\n\n"}
{"message":"aborting due to 4 previous errors; 6 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 4 previous errors; 6 warnings emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0277, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0277, E0599.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
